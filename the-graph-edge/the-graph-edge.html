<polymer-element name="the-graph-edge" attributes="source target route connection">
  <script>
  (function(){

    function makePath(sourceX, sourceY, targetX, targetY, scale){
      var nodeW = 60;
      var nodeW2 = 60 / 2;
      var nodeH = 60;
      var nodeH2 = 60 / 2;

      var startX, startY, endX, endY;
      var c1X, c1Y, c2X, c2Y;

      var xDiff = targetX - sourceX;
      var yDiff = targetY - sourceY;

      if (Math.abs(xDiff) < Math.abs(yDiff)){
        if (sourceY < targetY) {
          // S: bottom to top
          startX = sourceX + nodeW2;
          startY = sourceY + nodeH;
          endX = targetX + nodeW2;
          endY = targetY;
          c1X = startX;
          c1Y = startY + (endY - startY)/2;
          c2X = endX;
          c2Y = c1Y;
        } else {
          // N bottom to right
          startX = sourceX + nodeW2;
          startY = sourceY + nodeH;
          endX = targetX;
          endY = targetY + nodeH2;
          c1X = startX + ( startX<endX ? nodeW : 0-nodeW );
          c1Y = startY + nodeH;
          c2X = endX - nodeW;
          c2Y = endY;
        }
      } else {
        if (sourceX < targetX) {
          // E: left to right
          startX = sourceX + nodeW;
          startY = sourceY + nodeH2;
          endX = targetX;
          endY = targetY + nodeH2;
          c1X = startX + (endX - startX)/2;
          c1Y = startY;
          c2X = c1X;
          c2Y = endY;
        } else {
          // W right to top
          startX = sourceX + nodeW;
          startY = sourceY + nodeH2;
          endX = targetX + nodeW2;
          endY = targetY;
          c1X = startX + nodeW;
          c1Y = startY + ( startY<endY ? nodeH : 0-nodeH );
          c2X = endX;
          c2Y = endY - nodeH;
        }
      }

      // Scale edge
      startX = Math.round(startX*scale);
      startY = Math.round(startY*scale);
      endX = Math.round(endX*scale);
      endY = Math.round(endY*scale);
      c1X = Math.round(c1X*scale);
      c1Y = Math.round(c1Y*scale);
      c2X = Math.round(c2X*scale);
      c2Y = Math.round(c2Y*scale);

      var d = [
        "M", startX, startY, 
        "C", c1X, c1Y,
             c2X, c2Y,
             endX, endY
      ];

      return d.join(" ");
    }

    Polymer('the-graph-edge', {
      route: 0,
      zoom: 1,
      created: function () {
      },
      enteredView: function () {
        var graph = this.parentNode.parentNode;
        var self = this;
        graph.addEventListener("zoomed", function(event){
          self.zoom = graph.zoom;
        });
        setTimeout(this.checkParent.bind(this), 0);
      },
      checkParent: function () {
        var rootSVG = this.parentNode.getElementsByTagName('svg')[0];
        this.path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        this.routeChanged();
        rootSVG.appendChild(this.path);
        this.drawEdge();
      },
      connectionChanged: function () {
        // Reference to the actual node list
        this.nodes = this.connection.nodes;

        // Other connection attributes
        this.source = this.connection.src.process + '.' + this.connection.src.port;
        this.target = this.connection.tgt.process + '.' + this.connection.tgt.port;
        if (this.connection.metadata) {
          this.route = this.connection.metadata.route;
        }
      },
      routeChanged: function () {
        if (!this.path) { return; }
        this.path.setAttributeNS(null, "class", "edge route"+this.route );
      },
      drawEdge: function () {
        if (!this.path || !this.sourceNode || !this.targetNode) { return; }

        var source = this.sourceNode.getAttribute('position').split(' ');
        var target = this.targetNode.getAttribute('position').split(' ');
        var sourceX = parseFloat(source[0]);
        var sourceY = parseFloat(source[1]);
        var targetX = parseFloat(target[0]);
        var targetY = parseFloat(target[1]);

        var d = makePath(sourceX, sourceY, targetX, targetY, this.zoom);

        this.path.setAttributeNS(null, "d", d);
      },
      sourceChanged: function () {
        var split = this.source.split(".");
        var sourceNode = document.getElementsByName( split[0] );
        if (sourceNode.length !== 1) { return; }
        this.sourceNode = sourceNode[0];
        this.sourceNode.addEventListener("moved", this.sourceMoved.bind(this));
        this.sourceMoved();

        // Find/make port
        // var outports = this.sourceNode.querySelector("the-graph-outports"); 
        // var outport = outports.querySelector('port[name="'+split[1]+'"]');
        // if (!outport) {
        //   outport = document.createElement("the-graph-port");
        //   outport.setAttribute("name", split[1]);
        //   outports.appendChild(outport);
        // }
        // console.log(outport);
        // this.sourcePort = outport;
      },
      sourceMoved: function () {
        this.drawEdge();
      },
      targetChanged: function () {
        var split = this.target.split(".");
        var targetNode = document.getElementsByName( split[0] );
        if (targetNode.length !== 1) { return; }
        this.targetNode = targetNode[0];
        this.targetNode.addEventListener("moved", this.targetMoved.bind(this));
        this.targetMoved();
      },
      targetMoved: function () {
        this.drawEdge();
      },
      zoomChanged: function () {
        this.drawEdge();
      }
    });

  })()
  </script>
  
</polymer-element>
