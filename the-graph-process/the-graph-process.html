<link rel="import" href="../the-graph-inports/the-graph-inports.html">
<link rel="import" href="../the-graph-outports/the-graph-outports.html">
<polymer-element name="the-graph-process" attributes="label position drag component process highlight icon" lightdom>

  <template>
    <h1 class="the-graph-process-label">{{label}}</h1>
    <i class="icon icon-{{icon}}"></i>
    <the-graph-inports id="inports">
      <template repeat="{{port in inports}}">
        <the-graph-port name="{{port.name}}" type="{{port.type}}"></the-graph-port> 
      </template>
    </the-graph-inports>
    <the-graph-outports id="outports">
      <template repeat="{{port in outports}}">
        <the-graph-port name="{{port.name}}" type="{{port.type}}"></the-graph-port> 
      </template>
    </the-graph-outports>
  </template>

  <script type="text/javascript" src="../the-graph-util/the-graph-util.js"></script>

  <script>
  (function(){

    Polymer('the-graph-process', {
      label: '',
      component: '',
      icon: '',
      position: '0 0',
      drag: '',
      zoom: 1,
      pan: {
        x: 0,
        y: 0
      },
      bump: {
        x: 500,
        y: 500
      },
      snap: 35,
      width: 60,
      height: 60,
      libraryComponent: null,
      inports: [],
      outports: [],
      ready: function () {
        var pos = this.getPosition();
        this._position = [pos.x, pos.y];
      },
      enteredView: function () {
        var graph = this.parentNode.parentNode;
        this.graph = graph;
        
        // Oh snap
        this.addEventListener("pointerup", function(){
          setTimeout(this.snapToGrid.bind(this), 100);
        }.bind(this));

        // Initial bump
        this.bump.x = graph.padding;
        this.bump.y = graph.padding;

        // Handle sizing
        this.graphZoom(this.zoom);

        this.addEventListener('click', this.onClick.bind(this), false);
      },
      libraryComponentChanged: function () {
        this.icon = this.libraryComponent.icon;
        this.inports = [];
        this.outports = [];
        this.libraryComponent.inports.forEach(function (port) {
          this.inports.push(port);
        }.bind(this));
        this.libraryComponent.outports.forEach(function (port) {
          this.outports.push(port);
        }.bind(this));
        this.fire('ports', {
          inports: this.inports,
          outports: this.outports
        });
        this.libraryComponent.addEventListener('icon', function (event) {
          this.icon = event.detail;
        }.bind(this));
        this.libraryComponent.addEventListener('inports', function (event) {
          event.detail.forEach(function (portDef) {
            var port = null;
            this.inports.forEach(function (p) {
              if (p.name === portDef.name) {
                port = p;
              }
            });
            if (!port) {
              this.inports.push(portDef);
              return;
            }
            port.type = portDef.type;
            port.array = portDef.array;
          }.bind(this));
        }.bind(this));
        this.libraryComponent.addEventListener('outports', function (event) {
          event.detail.forEach(function (portDef) {
            var port = null;
            this.outports.forEach(function (p) {
              if (p.name === portDef.name) {
                port = p;
              }
            });
            if (!port) {
              this.outports.push(portDef);
              return;
            }
            port.type = portDef.type;
            port.array = portDef.array;
          }.bind(this));
        }.bind(this));
      },
      gridChanged: function () {
        this.width = this.grid - 1;
        this.height = this.grid - 1;
        this.graphZoom(this.zoom);
      },
      getInports: function () {
        return Array.prototype.slice.call(this.$.inports.getElementsByTagName('the-graph-port'));
      },
      getInportByName: function (name) {
        var childNodes = this.getInports();
        var port = null;
        childNodes.forEach(function (child) {
          if (child.getAttribute('name') === name) {
            port = child;
          }
        });
        return port;
      },
      getOutports: function () {
        return Array.prototype.slice.call(this.$.outports.getElementsByTagName('the-graph-port'));
      },
      getOutportByName: function (name) {
        var childNodes = this.getOutports();
        var port = null;
        childNodes.forEach(function (child) {
          if (child.getAttribute('name') === name) {
            port = child;
          }
        });
        return port;
      },
      processChanged: function () {
        this.component = this.process.component;
        this.name = this.process.name;
        if (this.process.metadata) {
          this.position = this.process.metadata.x + ' ' + this.process.metadata.y;
        }
        if (!this.label) {
          this.label = this.name;
        }
      },
      graphPanBumpZoom: function (info) {
        this.pan.x = info.pan.x;
        this.pan.y = info.pan.y;
        this.graphBump(info.bump);
        if (this.zoom !== info.zoom) {
          this.graphZoom(info.zoom);
        }
      },
      graphBump: function (bump) {
        this.bump.x = bump.x;
        this.bump.y = bump.y;
        var position = this.getZoomedPosition();
        theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);
      },
      graphZoom: function (zoom) {
        this.zoom = zoom;

        // Set position by screen pixels
        var position = this.getZoomedPosition();
        theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);

        // Sizing
        var diameter = this.getDiameter();
        this.style.width = diameter + 'px';
        this.style.height = diameter + 'px';

        // Update all ports
        var ports = Array.prototype.slice.call(this.getElementsByTagName('the-graph-port'));
        ports.forEach(function(port){
          port.graphZoom();
        }.bind(this));
      },
      getPosition: function () {
        // return this._position;
        var position = this.position.split(' ');
        return {
          x: parseInt(position[0]),
          y: parseInt(position[1])
        };
      },
      getZoomedPosition: function () {
        var position = this.getPosition();
        return {
          x: Math.round(position.x*this.zoom),
          y: Math.round(position.y*this.zoom)
        };
      },
      getDrag: function () {
        var drag = this.drag.split(' ');
        return {
          x: parseInt(drag[0]),
          y: parseInt(drag[1])
        };
      },
      dragChanged: function () {
        if (this.highlight) {
          return;
        }
        var drag = this.getDrag();
        var x = drag.x / this.zoom - this.pan.x / this.zoom;
        x -= this.clientWidth / 2;
        x = Math.round(x);
        var y = drag.y / this.zoom - this.pan.y / this.zoom;
        y -= this.clientHeight / 2;
        y = Math.round(y);

        this.position = x + ' ' + y;
      },
      snapToGrid: function () {
        // Called on pointerup with a short delay
        var x = this._position[0];
        var y = this._position[1];
        x = Math.round(x / this.snap) * this.snap;
        y = Math.round(y / this.snap) * this.snap;

        this.position = x + ' ' + y;
      },
      nameChanged: function () {
        this.setAttribute('name', this.name);
      },
      // _positionChanged: function () {
      //   console.log(this._position);
      // },
      positionChanged: function () {
        var position = this.getPosition();
        this._position[0] = position.x;
        this._position[1] = position.y;

        position = this.getZoomedPosition();
        theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);
        this.fire('moved', {
          x: position.x,
          y: position.y
        });
      },
      getDiameter: function () {
        var diameter = Math.round(this.width * this.zoom);
        if (diameter < 24) {
          // Ensure sane touchable size
          return diameter = 24;
        }
        return diameter;
      },
      getHighlightDiameter: function () {
        // By default, nodes expand to double their size
        var diameter = Math.round(this.width * this.zoom * 2);

        // Count the maximum number of ports on a given side
        var ports = Array.prototype.slice.call(this.getElementsByTagName('the-graph-port'));
        var perSide = {
          east: 0,
          south: 0,
          west: 0,
          north: 0
        };
        ports.forEach(function (port) {
          perSide[port.side]++;
        });
        var portSize = 30;

        var sideArea = diameter * Math.PI / 4;
        var maxPortsPerSide = Math.max(perSide.east, perSide.south, perSide.west, perSide.north);
        if (sideArea / maxPortsPerSide < portSize) {
          diameter = maxPortsPerSide * portSize * 4 / Math.PI;
        }

        return diameter;
      },
      highlightChanged: function () {
        var position = this.getZoomedPosition();
        if (this.highlight) {
          // Focus the node
          var diameter = this.getHighlightDiameter();
          this.classList.add('highlight');
          this.style.width = diameter + "px";
          this.style.height = diameter + "px";
          this.style.zIndex = 11;
          this.style.borderRadius = diameter / 2 + "px";
          theGraph.transform(this, position.x - diameter / 4 + this.bump.x, position.y - diameter / 4 + this.bump.y);

          if (this.highlight === 'in') {
            this.$.inports.highlight = this.highlight;
            this.$.outports.highlight = '';
          } else {
            this.$.inports.highlight = '';
            this.$.outports.highlight = this.highlight;
          }
        } else {
          // Unfocus the node
          var diameter = this.getDiameter();
          this.style.width = diameter + "px";
          this.style.height = diameter + "px";
          this.style.zIndex = 10;
          this.style.borderRadius = '';
          this.classList.remove('highlight');
          theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);

          if (this.highlight === 'in') {
            this.$.inports.highlight = '';
          } else {
            this.$.outports.highlight = '';
          }
        }
        this.fire('highlight', this.highlight);
      },
      onClick: function () {
        this.fire('nodeclick', this);
      }
    });
  })()
  </script>
</polymer-element>

