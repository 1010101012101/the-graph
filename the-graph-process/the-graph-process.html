<link rel="import" href="../the-graph-inports/the-graph-inports.html">
<link rel="import" href="../the-graph-outports/the-graph-outports.html">
<polymer-element name="the-graph-process" attributes="label position drag component process highlight icon" lightdom>

  <template>
    <h1 class="the-graph-process-label">{{label}}</h1>
    <i class="icon icon-{{icon}}"></i>
    <the-graph-inports>
      <template repeat="{{port in inports}}">
        <the-graph-port name="{{port.name}}" type="{{port.type}}"></the-graph-port> 
      </template>
    </the-graph-inports>
    <the-graph-outports>
      <template repeat="{{port in outports}}">
        <the-graph-port name="{{port.name}}" type="{{port.type}}"></the-graph-port> 
      </template>
    </the-graph-outports>
  </template>

  <script type="text/javascript" src="../the-graph-util/the-graph-util.js"></script>

  <script>
    Polymer('the-graph-process', {
      label: '',
      icon: '',
      position: '0 0',
      drag: '',
      zoom: 1,
      pan: {
        x: 0,
        y: 0
      },
      bump: {
        x: 500,
        y: 500
      },
      width: 60,
      height: 60,
      libraryComponent: null,
      inports: [],
      outports: [],
      created: function () {
        this.style.position = 'absolute';
      },
      enteredView: function () {
        var graph = this.parentNode.parentNode;
        this.graph = graph;
        graph.addEventListener("zoomed", function(event){
          this.zoom = event.detail;
        }.bind(this));
        graph.addEventListener("panned", function(event){
          this.pan = event.detail;
        }.bind(this));
        graph.addEventListener("bumped", function(event){
          this.graphBumped(event.detail);
        }.bind(this));

        // Insert ports based on library
        this.initializePorts();

        // Handle sizing
        this.zoomChanged();
      },
      initializePorts: function () {
        if (!this.libraryComponent) {
          var editor = this.parentNode.parentNode.parentNode;
          this.libraryComponent = editor.querySelector('the-component[name="' + this.component + '"]');
        }
        if (!this.libraryComponent) {
          return;
        }
        this.icon = this.libraryComponent.icon;
        this.inports = [];
        this.outports = [];
        this.libraryComponent.inports.forEach(function (port) {
          this.inports.push(port);
        }.bind(this));
        this.libraryComponent.outports.forEach(function (port) {
          this.outports.push(port);
        }.bind(this));
        this.fire('ports', {
          inports: this.inports,
          outports: this.outports
        });
      },
      processChanged: function () {
        this.component = this.process.component;
        this.name = this.process.name;
        if (this.process.metadata) {
          this.position = this.process.metadata.x + ' ' + this.process.metadata.y;
        }
        if (!this.label) {
          this.label = this.name;
        }
      },
      graphBumped: function (bump) {
        this.bump.x = bump.x;
        this.bump.y = bump.y;
        var position = this.getZoomedPosition();
        theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);
      },
      getPosition: function () {
        var position = this.position.split(' ');
        return {
          x: parseInt(position[0]),
          y: parseInt(position[1])
        };
      },
      getZoomedPosition: function () {
        var position = this.getPosition();
        return {
          x: Math.round(position.x * this.zoom),
          y: Math.round(position.y * this.zoom)
        };
      },
      getDrag: function () {
        var drag = this.drag.split(' ');
        return {
          x: parseInt(drag[0]),
          y: parseInt(drag[1])
        };
      },
      dragChanged: function () {
        if (this.highlight) {
          return;
        }
        var drag = this.getDrag();
        var x = drag.x / this.zoom - this.pan.x / this.zoom;
        x -= this.clientWidth / 2;
        var y = drag.y / this.zoom - this.pan.y / this.zoom;
        y -= this.clientHeight / 2;
        this.position = x + ' ' + y;
      },
      nameChanged: function () {
        this.setAttribute('name', this.name);
      },
      positionChanged: function () {
        var position = this.getZoomedPosition();
        theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);
        this.fire('moved', {
          x: position.x,
          y: position.y
        });
      },
      zoomChanged: function () {
        // Set position by screen pixels
        var position = this.getZoomedPosition();
        theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);

        // Sizing
        var diameter = this.getDiameter();
        this.style.width = diameter + 'px';
        this.style.height = diameter + 'px';

        this.fire('zoomed', this.zoom);
      },
      getDiameter: function () {
        var diameter = Math.round(this.width * this.zoom);
        if (diameter < 24) {
          // Ensure sane touchable size
          return diameter = 24;
        }
        return diameter;
      },
      getHighlightDiameter: function () {
        // By default, nodes expand to double their size
        var diameter = Math.round(this.width * this.zoom * 2);

        // Count the maximum number of ports on a given side
        var ports = Array.prototype.slice.call(this.getElementsByTagName('the-graph-port'));
        var perSide = {
          east: 0,
          south: 0,
          west: 0,
          north: 0
        };
        ports.forEach(function (port) {
          perSide[port.side]++;
        });
        var portSize = 30;

        var sideArea = diameter * Math.PI / 4;
        var maxPortsPerSide = Math.max(perSide.east, perSide.south, perSide.west, perSide.north);
        if (sideArea / maxPortsPerSide < portSize) {
          diameter = maxPortsPerSide * portSize * 4 / Math.PI;
        }

        return diameter;
      },
      highlightChanged: function () {
        var position = this.getZoomedPosition();
        if (this.highlight) {
          // Focus the node
          var diameter = this.getHighlightDiameter();
          this.classList.add('highlight');
          this.style.width = diameter + "px";
          this.style.height = diameter + "px";
          this.style.zIndex = 11;
          this.style.borderRadius = diameter / 2 + "px";
          theGraph.transform(this, position.x - diameter / 4 + this.bump.x, position.y - diameter / 4 + this.bump.y);

          if (this.highlight === 'in') {
            this.querySelector('the-graph-inports').highlight = this.highlight;
            this.querySelector('the-graph-outports').highlight = '';
          } else {
            this.querySelector('the-graph-outports').highlight = this.highlight;
            this.querySelector('the-graph-inports').highlight = '';
          }
        } else {
          // Unfocus the node
          var diameter = this.getDiameter();
          this.style.width = diameter + "px";
          this.style.height = diameter + "px";
          this.style.zIndex = 10;
          this.style.borderRadius = '';
          this.classList.remove('highlight');
          theGraph.transform(this, position.x + this.bump.x, position.y + this.bump.y);

          if (this.highlight === 'in') {
            this.querySelector('the-graph-inports').highlight = '';
          } else {
            this.querySelector('the-graph-outports').highlight = '';
          }
        }
        this.fire('highlight', this.highlight);
      }
    });
  </script>
</polymer-element>

