<link rel="import" href="../the-graph-exports/the-graph-exports.html">
<link rel="import" href="../the-graph-nodes/the-graph-nodes.html">
<link rel="import" href="../the-graph-edges/the-graph-edges.html">
<link rel="import" href="../the-graph-initials/the-graph-initials.html">
<link rel="import" href="../bower_components/the-behavior/the-behavior/the-behavior.html">

<polymer-element name="the-graph" attributes="pan drag scale" lightdom>

  <template>
    <content select="the-behavior"></content>
    <the-graph-nodes id="nodes"></the-graph-nodes>
    <the-graph-edges id="edges"></the-graph-edges>
    <the-graph-initials></the-graph-initials>
    <the-graph-exports></the-graph-exports>
  </template>

  <script type="text/javascript" src="../the-graph-util/the-graph-util.js"></script>

  <script>
    Polymer('the-graph', {
      // The pan state attribute
      pan: '0 0',
      // The actual pan state
      _pan: {
        x: 0,
        y: 0
      },
      drag: {
        x: 0,
        y: 0
      },
      // The actual zoom state
      zoom: 1,
      // User-visible zoom state
      scale: 1,
      // Infinite scroll bounds
      padding: 500,
      bump: {
        x: 500,
        y: 500
      },
      minX: 0,
      minY: 0,
      maxX: 2000,
      maxY: 2000,
      enteredView: function () {
        if (this.$.graphpinch) {
          this.$.graphpinch.addEventListener('gesture', function (e) {
            this.zooming(e.detail.scale, e.detail.center);

            // Ensure the end method gets called
            var later = function () {
              this.zoomed(e.detail.scale, e.detail.center);
            }.bind(this);
            clearTimeout(this.zoomDebounce);
            this.zoomDebounce = setTimeout(later, 750);
          }.bind(this));
          this.$.graphpinch.addEventListener('gestureend', function (e) {
            clearTimeout(this.zoomDebounce);
            this.zoomed(e.detail.scale, e.detail.center);
          }.bind(this));
        }
        if (this.$.graphpan) {
          this.$.graphpan.addEventListener('gesture', function (e) {
            var touch = e.detail[Object.keys(e.detail)[0]];
            if (!touch.movepoint) {
              return;
            }
            var panX = touch.movepoint.x - touch.startpoint.x;
            var panY = touch.movepoint.y - touch.startpoint.y;
            // Handle panning in relation to previous panning state
            var pan = this.getPan();
            var newPan = {
              x: panX + pan.x,
              y: panY + pan.y
            }
            this.panning(newPan, 1);

            // Ensure the end method gets called
            var later = function () {
              this.panned(newPan);
            }.bind(this);
            clearTimeout(this.panDebounce);
            this.panDebounce = setTimeout(later, 750);
          }.bind(this));
          this.$.graphpan.addEventListener('gestureend', function (e) {
            clearTimeout(this.panDebounce);
            var touch = e.detail[Object.keys(e.detail)[0]];
            var panX = touch.movepoint.x - touch.startpoint.x;
            var panY = touch.movepoint.y - touch.startpoint.y;
            // Handle panning in relation to previous panning state
            var pan = this.getPan();
            var newPan = {
              x: panX + pan.x,
              y: panY + pan.y
            }
            this.panned(newPan);
          }.bind(this));
        }
        if (this.$.nodehighlight) {
          var sourceNode = null;
          var sourcePort = null;
          var targetNode = null;
          var targetPort = null;
          this.$.nodehighlight.addEventListener('gesture', function (e) {
            var touch = e.detail[Object.keys(e.detail)[0]];
            if (touch.endelement) {
              return;
            }
            if (!touch.startelement) {
              return;
            }
            if (!sourceNode) {
              // Start of the gesture, highlight
              sourceNode = touch.startelement;
              if (touch.angle > 180 && touch.angle < 359) {
                sourceNode.highlight = 'in';

                // Select first inport
                sourcePort = sourceNode.querySelector('the-graph-inports the-graph-port');
                if (sourcePort) {
                  sourcePort.classList.toggle('selected');
                }
              } else {
                sourceNode.highlight = 'out';

                // Select first inport
                sourcePort = sourceNode.querySelector('the-graph-outports the-graph-port');
                if (sourcePort) {
                  sourcePort.classList.toggle('selected');
                }
              }
            }

            if (sourcePort && touch.current.nodeName === 'THE-GRAPH-PROCESS' && touch.current !== sourceNode) {
              if (targetNode) {
                if (targetNode == touch.current) {
                  return;
                }
                targetNode.highlight = '';
              }
              targetNode = touch.current;
              if (sourceNode.highlight === 'in') {
                targetNode.highlight = 'out';

                // Select first outport
                targetPort = targetNode.querySelector('the-graph-outports the-graph-port');
                if (targetPort) {
                  console.log(targetPort);
                  targetPort.classList.toggle('selected');
                }
              } else {
                targetNode.highlight = 'in';

                // Select first inport
                targetPort = targetNode.querySelector('the-graph-inports the-graph-port');
                if (targetPort) {
                  console.log(targetPort);
                  targetPort.classList.toggle('selected');
                }
              }
            }

            if (touch.current.nodeName === 'THE-GRAPH-PORT') {
              if (touch.current.parentNode.parentNode === sourceNode) {
                if (sourcePort) {
                  sourcePort.classList.toggle('selected');
                }
                sourcePort = touch.current;
                sourcePort.classList.toggle('selected');
              } else {
                if (sourcePort.canConnect(touch.current)) {
                  if (targetPort) {
                    targetPort.classList.toggle('selected');
                  }
                  targetPort = touch.current;
                  targetPort.classList.toggle('selected');
                }
              }
            }

            var later = function () {
              if (sourceNode) {
                sourceNode.highlight = '';
              }
              if (targetNode) {
                targetNode.highlight = '';
              }
              if (sourcePort) {
                sourcePort.classList.toggle('selected');
              }
              if (targetPort) {
                targetPort.classList.toggle('selected');
              }

              if (sourceNode && sourcePort && targetNode && targetPort) {
                // Make a connection!
                if (sourcePort.isOutport()) {
                  this.connect(sourceNode, sourcePort, targetNode, targetPort);
                } else {
                  this.connect(targetNode, targetPort, sourceNode, sourcePort);
                }
              }

              sourceNode = null;
              sourcePort = null;
              targetNode = null;
              targetPort = null;
            }.bind(this);

            clearTimeout(this.nodeDebounce);
            if (touch.endelement) {
              later();
            } else {
              this.nodeDebounce = setTimeout(later, 750);
            }
          }.bind(this));
        }

        // Handle passing zoom value to the GSS engine for node rescaling
        this.engine = GSS.engines[0];
        this.engine.registerCommand(["suggest", ["get","[zoom]"], this.zoom]);
        this.engine.solve();
      },
      getPan: function () {
        // var pan = this.pan.split(' ');
        // return {
        //   x: parseInt(pan[0]),
        //   y: parseInt(pan[1])
        // };
        return this._pan;
      },
      panDebounce: null,
      panning: function (pan, scale) {
        // This panning is with just css transform
        theGraph.transform(this, pan.x - this.bump.x, pan.y - this.bump.y, scale);
      },
      panned: function (pan) {
        // This moves elements
        this._pan.x = pan.x;
        this._pan.y = pan.y;
        this.pan = pan.x + ' ' + pan.y;

        this.calcBump();
        theGraph.transform(this, pan.x - this.bump.x, pan.y - this.bump.y);
        this.fire('panned', pan);
      },
      calcBump: function () {
        this.bump.x = Math.max(0, this._pan.x) + this.padding;
        this.bump.y = Math.max(0, this._pan.y) + this.padding;
        this.fire('bumped', this.bump);
        this.updateGridBg();
      },
      zoomDebounce: null,
      zooming: function (scale, center) {
        // Scale happens fast
        scale = Math.max(0.25/this.zoom, Math.min(scale, 6/this.zoom));
        var pan = this.getPan();
        this.panning({
          x: pan.x * scale,
          y: pan.y * scale
        }, scale);
      },
      zoomed: function (scale, center) {
        // Zoom causes a rerendering of graph elements
        scale = Math.max(0.25/this.zoom, Math.min(scale, 6/this.zoom));
        var zoom = this.zoom * scale;
        this.zoom = Math.max(0.25, Math.min(zoom, 6));
        this.fire("zoomed", this.zoom);

        this.engine.registerCommand(["suggest", ["get","[zoom]"], this.zoom, 'strong']);
        this.engine.solve();

        var pan = this.getPan();
        theGraph.transform(this, pan.x * scale, pan.y * scale, 1);
        // Update internal panning state based on scale
        this.panned({
          x: pan.x * scale,
          y: pan.y * scale
        });
        this.updateGridBg();
      },
      calcMinMax: function () {
        var minX = 0;
        var minY = 0;
        var maxX = window.innerWidth;
        var maxY = window.innerHeight;

        var processes = this.querySelector("the-graph-nodes").children;
        var len = processes.length;
        for (var i=0; i<len; i++) {
          var node = processes[i];
          if (node.getPosition) {
            var pos = node.getPosition();
            if (pos.x < minX) {
              minX = pos.x;
            }
            if (pos.y < minY) {
              minX = pos.x;
            }
            if (pos.x > maxX) {
              maxX = pos.x;
            }
            if (pos.y > maxY) {
              maxY = pos.y;
            }
          }
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;

        this.updatePaddedSize();
      },
      updatePaddedSize: function () {
        this.style.width = -this.minX + this.maxX + this.padding*2 + "px";
        this.style.height = -this.minY + this.maxY + this.padding*2 + "px";
        this.updateGridBg();
      },
      updateGridBg: function () {
        // Update CSS grid image
        this.style.backgroundSize = (70*this.zoom)+"px "+(70*this.zoom)+"px";
        this.style.backgroundPosition = (this.bump.x)+"px "+(this.bump.y)+"px";        
      },
      graphChanged: function () {
        var nodes = this.querySelector("the-graph-nodes");
        var edges = this.querySelector("the-graph-edges");
        var initials = this.querySelector("the-graph-initials");
        var exports = this.querySelector("the-graph-exports");

        // Convert processes to an array
        for (var index in this.graph.processes) {
          var p = this.graph.processes[index];
          p.name = index;
          if (!p.metadata.label) {
            p.metadata.label = p.name;
          }
          nodes.processes.push(p);
        }

        // Make connection elements
        this.graph.connections.forEach(function (connection) {
          if (connection.src) {
            edges.connections.push(connection);
          }
          return;
          initials.iips.push(connection);
        });

        this.calcMinMax();
      },
      connect: function (sourceNode, sourcePort, targetNode, targetPort) {
        var edges = this.querySelector("the-graph-edges");
        edges.connections.push({
          src: {
            process: sourceNode.getAttribute('name'),
            port: sourcePort.name
          },
          tgt: {
            process: targetNode.getAttribute('name'),
            port: targetPort.name
          }
        });
      }
    });
  </script>
  
</polymer-element>
