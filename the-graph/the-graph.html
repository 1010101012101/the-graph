<link rel="import" href="../the-graph-exports/the-graph-exports.html">
<link rel="import" href="../the-graph-nodes/the-graph-nodes.html">
<link rel="import" href="../the-graph-edges/the-graph-edges.html">
<link rel="import" href="../the-graph-initials/the-graph-initials.html">
<link rel="import" href="../bower_components/the-behavior/the-behavior/the-behavior.html">

<polymer-element name="the-graph" attributes="panx pany scale" lightdom>

  <template>
    <content select="the-behavior"></content>
    <the-graph-nodes id="nodes"></the-graph-nodes>
    <the-graph-edges id="edges"></the-graph-edges>
    <the-graph-initials></the-graph-initials>
    <the-graph-exports></the-graph-exports>
  </template>

  <script type="text/javascript" src="../the-graph-util/the-graph-util.js"></script>

  <script>
    Polymer('the-graph', {
      panx: 0,
      pany: 0,
      zoom: 1,
      created: function () {
      },
      enteredView: function () {
        var getDistance = function (origin, destination) {
          var deltaX = destination.x - origin.x;
          var deltaY = destination.y - origin.y;
          var origin = null;
          var destination = null;
          var distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          return distance;
        }

        this.querySelector('the-behavior[type="pinch"]').addEventListener('gesture', function (e) {
          var startX = [];
          var startY = [];
          var startPoints = [];
          var movePoints = [];
          for (var touch in e.detail) {
            if (e.detail[touch].startpoint) {
              startX.push(e.detail[touch].startpoint.x);
              startY.push(e.detail[touch].startpoint.y);
              startPoints.push(e.detail[touch].startpoint);
            }
            if (e.detail[touch].movepoint) {
              movePoints.push(e.detail[touch].movepoint);
            }
          }
          var center = {
            x: ((Math.min.apply(Math, startX) + Math.max.apply(Math, startX)) / 2),
            y: ((Math.min.apply(Math, startY) + Math.max.apply(Math, startY)) / 2)
          };
          var scale = 1;
          if (startPoints.length > 1 && movePoints.length > 1) {
            scale = getDistance(movePoints[0], movePoints[1]) / getDistance(startPoints[0], startPoints[1]);
          }
          this.scale = scale;
        }.bind(this));
      },
      panxChanged: function () {
        this.panChanged();
      },
      panyChanged: function () {
        this.panChanged();
      },
      panDebounce: null,
      panChanged: function () {
        var self = this;
        var later = function(){
          self.panDebounce = null;
          theGraph.transform(self, self.panx, self.pany, self.scale);
          self.fire('panned', {
            x: self.panx,
            y: self.pany
          });
        }
        clearTimeout(this.panDebounce);
        this.panDebounce = setTimeout(later, 16);
      },
      scale: 1,
      scaleChanged: function () {
        // Scale happens fast
        theGraph.transform(this, this.panx, this.pany, this.scale/this.zoom);
        this.zoomDone();
      },
      zoomDebounce: null,
      zoomDone: function () {
        // Zoom causes a rerendering of graph elements
        var self = this;
        var later = function(){
          self.zoomDebounce = null;
          self.zoom = self.scale;
          self.fire("zoomed", self.zoom);
          theGraph.transform(self, self.panx, self.pany, 1);
          self.style.backgroundSize = (70*self.zoom)+"px "+(70*self.zoom)+"px";
        }
        clearTimeout(this.zoomDebounce);
        this.zoomDebounce = setTimeout(later, 750);
      },
      graphChanged: function () {
        var nodes = this.querySelector("the-graph-nodes");
        var edges = this.querySelector("the-graph-edges");
        var initials = this.querySelector("the-graph-initials");
        var exports = this.querySelector("the-graph-exports");

        // Convert processes to an array
        for (var index in this.graph.processes) {
          var p = this.graph.processes[index];
          p.name = index;
          nodes.processes.push(p);
        }

        // Make connection elements
        this.graph.connections.forEach(function (connection) {
          if (connection.src) {
            edges.connections.push(connection);
          }
          return;
          initials.iips.push(connection);
        });

      }
    });
  </script>
  
</polymer-element>
