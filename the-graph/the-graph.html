<link rel="import" href="../the-graph-exports/the-graph-exports.html">
<link rel="import" href="../the-graph-nodes/the-graph-nodes.html">
<link rel="import" href="../the-graph-edges/the-graph-edges.html">
<link rel="import" href="../the-graph-initials/the-graph-initials.html">
<link rel="import" href="../bower_components/the-behavior/the-behavior/the-behavior.html">

<polymer-element name="the-graph" attributes="drag zoom" lightdom>

  <template>
    <content select="the-behavior"></content>
    <the-graph-nodes id="nodes"></the-graph-nodes>
    <the-graph-edges id="edges"></the-graph-edges>
    <the-graph-initials></the-graph-initials>
    <the-graph-exports></the-graph-exports>
  </template>

  <script type="text/javascript" src="../the-graph-util/the-graph-util.js"></script>

  <script>
    Polymer('the-graph', {
      // The actual pan state
      pan: '0 0',
      // User-visible pan state
      drag: {
        x: 0,
        y: 0
      },
      // The actual zoom state
      zoom: 1,
      // User-visible zoom state
      scale: 1,
      enteredView: function () {
        if (this.$.graphpinch) {
          this.$.graphpinch.addEventListener('gesture', function (e) {
            var finished = false
            for (var touch in e.detail) {
              if (e.detail[touch].endpoint) {
                finished = true;
              }
            }
            if (!finished) {
              this.zooming(e.detail.scale);
            } else {
              this.zoomed(e.detail.scale);
            }
          }.bind(this));
        }
        if (this.$.graphpan) {
          this.$.graphpan.addEventListener('gesture', function (e) {
            var touch = e.detail[Object.keys(e.detail)[0]];
            if (!touch.movepoint) {
              return;
            }
            var panX = touch.movepoint.x - touch.startpoint.x;
            var panY = touch.movepoint.y - touch.startpoint.y;
            // Handle panning in relation to previous panning state
            var pan = this.getPan();
            var newPan = {
              x: panX + pan.x,
              y: panY + pan.y
            }
            if (!touch.endpoint) {
              this.panning(newPan);
            } else {
              this.panned(newPan);
            }
          }.bind(this));
        }
      },
      getPan: function () {
        var pan = this.pan.split(' ');
        return {
          x: parseInt(pan[0]),
          y: parseInt(pan[1])
        };
      },
      panning: function (pan) {
        theGraph.transform(this, pan.x, pan.y, 1);
        this.style.marginTop = 0 + 'px';
        this.style.marginLeft = 0 + 'px';
        this.panned(pan);
      },
      panDebounce: null,
      panned: function (pan) {
        var later = function () {
          theGraph.transform(this, 0, 0, 1);
          this.style.marginTop = pan.y + 'px';
          this.style.marginLeft = pan.x + 'px';
          this.pan = pan.x + ' ' + pan.y;
          this.fire('panned', pan);
        }.bind(this);
        // TODO: Read endpoint instead of debouncing
        clearTimeout(this.panDebounce);
        this.panDebounce = setTimeout(later, 750);
      },
      zooming: function (scale) {
        // Scale happens fast
        scale = Math.max(0.25/this.zoom, Math.min(scale, 6/this.zoom));
        var pan = this.getPan();
        theGraph.transform(this, pan.x, pan.y, scale);
      },
      zoomed: function (scale) {
        // Zoom causes a rerendering of graph elements
        this.zoomDebounce = null;
        scale = Math.max(0.25/this.zoom, Math.min(scale, 6/this.zoom));
        var zoom = this.zoom * scale;
        this.zoom = Math.max(0.25, Math.min(zoom, 6));
        this.fire("zoomed", this.zoom);
        var pan = this.getPan();
        theGraph.transform(this, pan.x, pan.y, 1);
        this.style.backgroundSize = (70*this.zoom)+"px "+(70*this.zoom)+"px";
      },
      graphChanged: function () {
        var nodes = this.querySelector("the-graph-nodes");
        var edges = this.querySelector("the-graph-edges");
        var initials = this.querySelector("the-graph-initials");
        var exports = this.querySelector("the-graph-exports");

        // Convert processes to an array
        for (var index in this.graph.processes) {
          var p = this.graph.processes[index];
          p.name = index;
          nodes.processes.push(p);
        }

        // Make connection elements
        this.graph.connections.forEach(function (connection) {
          if (connection.src) {
            edges.connections.push(connection);
          }
          return;
          initials.iips.push(connection);
        });

      }
    });
  </script>
  
</polymer-element>
