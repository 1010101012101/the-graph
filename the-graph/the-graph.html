<link rel="import" href="../the-graph-exports/the-graph-exports.html">
<link rel="import" href="../the-graph-nodes/the-graph-nodes.html">
<link rel="import" href="../the-graph-edges/the-graph-edges.html">
<link rel="import" href="../the-graph-initials/the-graph-initials.html">

<polymer-element name="the-graph" attributes="pan drag scale grid snap" lightdom>

  <template>
    <content select="the-behavior"></content>
    <the-graph-nodes id="nodes">
      <template repeat="{{ node in nodes }}">
        <the-graph-process name="{{node.name}}" position="{{node.metadata.x}} {{node.metadata.y}}" label="{{node.metadata.label}}" component="{{node.component}}"></the-graph-process>
      </template>
    </the-graph-nodes>
    <the-graph-edges id="edges">
      <template repeat="{{ edge in edges }}">
        <the-graph-edge source="{{ edge.source }}" target="{{ edge.target }}" route="{{ edge.metadata.route }}"></the-graph-edge>
      </template>
    </the-graph-edges>
    <the-graph-initials id="initials">
      <template repeat="{{ initial in initials }}">
        <the-graph-initial data="{{ initial.data }}" target="{{ initial.target }}"></the-graph-initial>
      </template>
    </the-graph-initials>
    <the-graph-exports></the-graph-exports>
  </template>

  <script type="text/javascript" src="../the-graph-util/the-graph-util.js"></script>

  <script>
  (function(){

    Polymer('the-graph', {
      // The pan state attribute
      pan: '0 0',
      // The actual pan state
      _pan: { x: 0, y: 0 },
      drag: { x: 0, y: 0 },
      // The actual zoom state
      zoom: 1,
      // User-visible zoom state
      scale: 1,
      // Infinite scroll bounds
      padding: 500,
      bump: { x: 500, y: 500 },
      scalePanD: { x: 0, y: 0 },
      minX: 0,
      minY: 0,
      maxX: 2000,
      maxY: 2000,
      grid: 70,
      snap: 35,
      nodes: [],
      edges: [],
      initials: [],
      exports: [],
      library: null,
      ready: function () {
        this._pan = { x: 0, y: 0 };
        this.drag = { x: 0, y: 0 };
        this.bump = { x: this.padding, y: this.padding };
        this.scalePanD = { x: 0, y: 0 };
      },
      enteredView: function () {
        if (this.$.graphpinch) {
          this.$.graphpinch.addEventListener('gesture', function (e) {
            if (e.detail.scale===1) {
              // Pan gesture event, don't zoom
              return;
            }
            this.zooming(e.detail.scale, e.detail.center);
          }.bind(this));
          this.$.graphpinch.addEventListener('gestureend', function (e) {
            if (e.detail.scale===1) {
              // Pan gestureend event, don't zoom
              return;
            }
            this.zoomed(e.detail.scale, e.detail.center);
          }.bind(this));
          this.observe();
        }
        if (this.$.graphpan) {
          this.$.graphpan.addEventListener('gesture', function (e) {
            var touch = e.detail[Object.keys(e.detail)[0]];
            if (!touch.movepoint) {
              return;
            }
            var panX = touch.movepoint.x - touch.startpoint.x;
            var panY = touch.movepoint.y - touch.startpoint.y;
            // Handle panning in relation to previous panning state
            var pan = this.getPan();
            var newPan = {
              x: panX + pan.x,
              y: panY + pan.y
            }
            this.panning(newPan, 1);
          }.bind(this));
          this.$.graphpan.addEventListener('gestureend', function (e) {
            var touch = e.detail[Object.keys(e.detail)[0]];
            var panX = touch.movepoint.x - touch.startpoint.x;
            var panY = touch.movepoint.y - touch.startpoint.y;
            // Handle panning in relation to previous panning state
            var pan = this.getPan();
            var newPan = {
              x: panX + pan.x,
              y: panY + pan.y
            }
            this.panned(newPan);
          }.bind(this));
        }
        if (this.$.nodehighlight) {
          var sourceNode = null;
          var sourcePort = null;
          var targetNode = null;
          var targetPort = null;
          this.$.nodehighlight.addEventListener('gesture', function (e) {
            var touch = e.detail[Object.keys(e.detail)[0]];
            if (touch.endelement) {
              return;
            }
            if (!touch.startelement) {
              return;
            }
            if (!sourceNode) {
              // Start of the gesture, highlight
              sourceNode = touch.startelement;
              if (touch.angle > 180 && touch.angle < 359) {
                sourceNode.highlight = 'in';

                // Select first inport
                sourcePort = sourceNode.getInports()[0];
                if (sourcePort) {
                  sourcePort.classList.toggle('selected');
                }
              } else {
                sourceNode.highlight = 'out';

                // Select first inport
                sourcePort = sourceNode.getOutports()[0];
                if (sourcePort) {
                  sourcePort.classList.toggle('selected');
                }
              }
            }

            if (sourcePort && touch.current.nodeName === 'THE-GRAPH-PROCESS' && touch.current !== sourceNode) {
              if (targetNode) {
                if (targetNode == touch.current) {
                  return;
                }
                targetNode.highlight = '';
                targetPort = null;
              }
              targetNode = touch.current;
              if (sourceNode.highlight === 'in') {
                targetNode.highlight = 'out';

                // Select first outport
                targetPort = targetNode.getOutports()[0];
                if (targetPort) {
                  targetPort.classList.toggle('selected');
                }
              } else {
                targetNode.highlight = 'in';

                // Select first inport
                targetPort = targetNode.getInports()[0];
                if (targetPort) {
                  targetPort.classList.toggle('selected');
                }
              }
            }

            if (touch.current.nodeName === 'THE-GRAPH-PORT') {
              if (touch.current.parentNode.parentNode === sourceNode) {
                if (sourceNode.highlight === 'in' && touch.current.isOutport()) {
                  return;
                }
                if (sourceNode.highlight === 'out' && !touch.current.isOutport()) {
                  return;
                }
                if (sourcePort) {
                  sourcePort.classList.toggle('selected');
                }
                sourcePort = touch.current;
                sourcePort.classList.toggle('selected');
              } else {
                if (sourcePort.canConnect(touch.current)) {
                  if (targetPort) {
                    targetPort.classList.toggle('selected');
                  }
                  targetPort = touch.current;
                  targetPort.classList.toggle('selected');
                }
              }
            }
          }.bind(this));
          this.$.nodehighlight.addEventListener('gestureend', function (e) {
            if (sourceNode) {
              sourceNode.highlight = '';
            }
            if (targetNode) {
              targetNode.highlight = '';
            }
            if (sourcePort) {
              sourcePort.classList.toggle('selected');
            }
            if (targetPort) {
              targetPort.classList.toggle('selected');
            }

            if (sourceNode && sourcePort && targetNode && targetPort) {
              // Make a connection!
              if (sourcePort.isOutport()) {
                this.connect(sourceNode, sourcePort, targetNode, targetPort);
                } else {
                this.connect(targetNode, targetPort, sourceNode, sourcePort);
              }
            }

            sourceNode = null;
            sourcePort = null;
            targetNode = null;
            targetPort = null;
          }.bind(this));
        }

        // Handle passing zoom value to the GSS engine for node rescaling
        //this.engine = GSS.engines[0];
        //this.engine.registerCommand(["suggest", ["get","[zoom]"], this.zoom]);
        //this.engine.solve();
      },
      getPan: function () {
        return this._pan;
      },
      panning: function (pan, scale) {
        // Panning is with just css transform
        theGraph.transform(this, pan.x - this.bump.x, pan.y - this.bump.y, scale);
      },
      panned: function (pan) {
        // At the end of the pan gesture, elements actually move
        this._pan.x = pan.x;
        this._pan.y = pan.y;
        this.pan = pan.x + ' ' + pan.y;

        var bump = this.calcBump();

        // this.fire('panned', {pan:pan, bump:bump});
        this.$.nodes.graphPanned( {pan:pan, bump:bump} );
        this.$.edges.graphBumped(bump); 

        theGraph.transform(this, pan.x - this.bump.x, pan.y - this.bump.y);
      },
      calcBump: function () {
        // For expanding in -x -y direction
        this.bump.x = Math.max(0, this._pan.x) + this.padding;
        this.bump.y = Math.max(0, this._pan.y) + this.padding;

        // For expanding in +x +y direction
        this.style.width = this.bump.x + 0-this._pan.x + window.innerWidth + this.padding*2 + "px";
        this.style.height = this.bump.y + 0-this._pan.y + window.innerHeight + this.padding*2 + "px";

        // the-edges and the-process listen to this
        // this.fire('bumped', this.bump);

        // Need to redraw CSS grid when size changed
        this.updateGridBg();

        return this.bump;
      },
      enhanceTimeout: null,
      scaleChanged: function () {
        // Fast-moving scale change
        // var scale = this.scale;
        var scaleD = this.scale / this.zoom;
        var pan = this.getPan();
        // TODO center for pinch
        var pageX = this.parentNode.offsetWidth/2; 
        var pageY = this.parentNode.offsetHeight/2;
        var currentX = pan.x - this.bump.x;
        var currentY = pan.y - this.bump.y;
        // This is a manual transform origin equivalent for pan.
        var oX = (currentX - pageX) * scaleD + pageX;
        var oY = (currentY - pageY) * scaleD + pageY;
        // To be corrected later
        this.scalePanD.x = oX + this.bump.x*scaleD;
        this.scalePanD.y = oY + this.bump.y*scaleD;

        theGraph.transform(this, oX, oY, scaleD);

        // Debounce "enhance"
        clearTimeout(this.enhanceTimeout);
        this.enhanceTimeout = setTimeout( this.scaleToZoom.bind(this), 500);
      },
      scaleToZoom: function () {
        // Debounced from scaleChanged
        clearTimeout(this.enhanceTimeout);
        this.zoom = this.scale;
      },
      zoomChanged: function () {
        // Slower zoom change that redraws graph, debounced from scaleChanged
        this.fire("zoomed", this.zoom);

        // Transform offset to pan
        this.panned(this.scalePanD);
        this.scalePanD.x = 0;
        this.scalePanD.y = 0;
      },
      zooming: function (scaleD, center) {
        // Scale change to scale
        // TODO center
        var scale = scaleD * this.zoom;
        this.scale = Math.max(0.25/this.zoom, Math.min(scale, 6/this.zoom));
      },
      zoomed: function () {
        // TODO Enhance immediately on gesture end?
        // clearTimeout(this.enhanceTimeout);
        // this.scaleToZoom();        
      },
      calcMinMax: function () {
        var minX = 0;
        var minY = 0;
        var maxX = window.innerWidth;
        var maxY = window.innerHeight;

        var processes = this.querySelector("the-graph-nodes").children;
        var len = processes.length;
        for (var i=0; i<len; i++) {
          var node = processes[i];
          if (node.getPosition) {
            var pos = node.getPosition();
            if (pos.x < minX) {
              minX = pos.x;
            }
            if (pos.y < minY) {
              minX = pos.x;
            }
            if (pos.x > maxX) {
              maxX = pos.x;
            }
            if (pos.y > maxY) {
              maxY = pos.y;
            }
          }
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;

        this.updatePaddedSize();
      },
      updatePaddedSize: function () {
        // XXX?
        this.style.width = -this.minX + this.maxX + this.padding*2 + "px";
        this.style.height = -this.minY + this.maxY + this.padding*2 + "px";
        this.updateGridBg();
      },
      updateGridBg: function () {
        // Update CSS grid image
        var size = Math.round(this.grid*this.zoom);
        this.style.backgroundSize = size+"px "+size+"px";
        this.style.backgroundPosition = (this.bump.x)+"px "+(this.bump.y)+"px";        
      },
      graphChanged: function () {
        var initials = this.querySelector("the-graph-initials");
        var exports = this.querySelector("the-graph-exports");

        // Convert processes to an array
        for (var index in this.graph.processes) {
          var p = this.graph.processes[index];
          p.name = index;
          if (!p.metadata.label) {
            p.metadata.label = p.name;
          }
          this.nodes.push(p);
        }

        // Make connection elements
        this.graph.connections.forEach(function (connection) {
          if (connection.src) {
            if (!connection.metadata) {
              connection.metadata = {};
            }
            this.edges.push({
              source: connection.src.process + '.' + connection.src.port,
              target: connection.tgt.process + '.' + connection.tgt.port,
              metadata: {
                route: connection.metadata.route ? connection.metadata.route : 0
              }
            });
            return;
          }
          this.initials.push({
            data: connection.data,
            target: connection.tgt.process + '.' + connection.tgt.port
          });
        }.bind(this));

        this.calcMinMax();
      },
      gridChanged: function () {
        var processes = this.$.nodes.getProcesses();
        processes.forEach(function (process) {
          process.grid = this.grid;
        }.bind(this));
        this.updateGridBg();
      },
      snapChanged: function () {
        var processes = this.$.nodes.getProcesses();
        processes.forEach(function (process) {
          process.snap = this.snap;
        }.bind(this));
      },
      connect: function (sourceNode, sourcePort, targetNode, targetPort) {
        this.edges.push({
          source: sourcePort.getNodeName() + '.' + sourcePort.name,
          target: targetPort.getNodeName() + '.' + targetPort.name,
          metadata: {
            route: 0
          }
        });
      },
      observer: null,
      handleMutations: function (mutations) {
        mutations.forEach(function (mutation) {
          var addedNodes = Array.prototype.slice.call(mutation.addedNodes);
          addedNodes.forEach(function (node) {
            switch (node.nodeName) {
              case 'THE-GRAPH-PORT':
                // Give the port to any edges that may be waiting for it
                var portName = node.getAttribute('name');
                var nodeName = node.getNodeName();
                var edges = this.$.edges.getEdgesBySide(nodeName + '.' + portName);
                edges.forEach(function (edge) {
                  if (node.isOutport()) {
                    edge.sourcePort = node;
                  } else {
                    edge.targetPort = node;
                  }
                });
                break;
              case 'THE-GRAPH-PROCESS':
                // Provide the component to the process
                node.libraryComponent = this.library.getComponent(node.component);
                node.grid = this.grid;
                node.snap = this.snap;
                break;
              case 'THE-GRAPH-EDGE':
                // Provide the edge with the information from DOM
                var source = node.getSource();
                node.sourceNode = this.$.nodes.getProcessByName(source.node);
                if (node.sourceNode) {
                  node.sourcePort = node.sourceNode.getOutportByName(source.port);
                }
                var target = node.getTarget();
                node.targetNode = this.$.nodes.getProcessByName(target.node);
                if (node.targetNode) {
                  node.targetPort = node.targetNode.getInportByName(target.port);
                }
                break;
            }
          }.bind(this));
          var removedNodes = Array.prototype.slice.call(mutation.removedNodes);
          removedNodes.forEach(function (node) {
            switch (node.nodeName) {
              case 'THE-GRAPH-PROCESS':
                var edges = this.$.edges.getEdges();
                edges.forEach(function (edge) {
                  if (edge.sourceNode === node || edge.targetNode === node) {
                    this.$.edges.removeChild(edge);
                  }
                }.bind(this));
                break;
            }
          }.bind(this));
        }.bind(this));
      },
      observe: function () {
        this.observer = new MutationObserver(this.handleMutations.bind(this));
        this.observer.observe(this, {
          subtree: true,
          childList: true,
          attributes: false,
          characterData: false
        });
      },
      leftView: function () {
        if (this.observer) {
          this.observer.disconnect();
        }
      },
      toJSON: function () {
        var definition = {
          properties: {},
          exports: [],
          processes: {},
          connections: []
        };
        this.$.nodes.getProcesses().forEach(function(node) {
          var nodeId = node.getAttribute('name');
          var nodePos = node.getPosition();
          definition.processes[nodeId] = {
            component: node.component,
            metadata: {
              x: nodePos.x,
              y: nodePos.y,
              label: node.label
            }
          };
        });
        this.$.edges.getEdges().forEach(function(edge) {
          var edgeSource = edge.getSource();
          var edgeTarget = edge.getTarget();
          definition.connections.push({
            src: {
              process: edgeSource.node,
              port: edgeSource.port
            },
            tgt: {
              process: edgeTarget.node,
              port: edgeTarget.port
            }
          });
        });
        this.$.initials.getInitials().forEach(function(initial) {
          var initialTarget = initial.getTarget();
          definition.connections.push({
            data: initial.data,
            tgt: {
              process: initialTarget.node,
              port: initialTarget.port
            }
          });
        });
        return definition;
      }
    });
  })()
  </script>
</polymer-element>
