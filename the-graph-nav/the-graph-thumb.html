<polymer-element name="the-graph-thumb" attributes="graph width height" lightdom>
  <template>
    <canvas id="canvas" width="{{width}}" height="{{height}}"></canvas>
  </template>
  <script>
  (function () {

    Polymer('the-graph-thumb', {
      graph: null,
      scale: 1,
      nodeSize: 60,
      fillStyle: "white",
      strokeStyle: "white",
      lineWidth: 1,
      edgeColors: [
        "white",
        "hsl(  0, 100%, 60%)",
        "hsl( 30, 100%, 60%)",
        "hsl( 60, 100%, 60%)",
        "hsl( 90, 100%, 60%)",
        "hsl(120, 100%, 60%)",
        "hsl(150, 100%, 60%)",
        "hsl(180, 100%, 60%)",
        "hsl(210, 100%, 60%)",
        "hsl(240, 100%, 60%)",
        "hsl(270, 100%, 60%)",
        "hsl(300, 100%, 60%)",
        "hsl(330, 100%, 60%)"
      ],
      ready: function () {
        this.context = this.$.canvas.getContext("2d");
        this.resetStyles();
      },
      enteredView: function () {
      },
      redrawGraph: function () {
        if (!this.graph || !this.graph.processes) { return; }
        // Clear
        this.context.clearRect(0, 0, this.width, this.height);
        // Find dimensions
        var toDraw = [];
        var minX = 0;
        var minY = 0;
        var maxX = 500;
        var maxY = 500;
        Object.keys(this.graph.processes).forEach(function(key){
          var process = this.graph.processes[key];
          if ( process.metadata && !isNaN(process.metadata.x) && !isNaN(process.metadata.y) ) {
            toDraw.push(process);
            minX = Math.min(minX, process.metadata.x);
            minY = Math.min(minY, process.metadata.y);
            maxX = Math.max(maxX, process.metadata.x);
            maxY = Math.max(maxY, process.metadata.y);
          }
        }.bind(this));
        maxX += this.nodeSize*2;
        maxY += this.nodeSize*2;
        var w = maxX - minX;
        var h = maxY - minY;
        // Scale dimensions
        var scale = (w > h) ? this.width/w : this.height/h;
        var size = Math.round(this.nodeSize * scale);
        var sizeHalf = size / 2;
        // Draw edges
        Object.keys(this.graph.connections).forEach(function(key){
          var connection = this.graph.connections[key];
          if (!connection.src || !connection.tgt) { return; }
          var source = this.graph.processes[connection.src.process];
          var target = this.graph.processes[connection.tgt.process];
          // Draw path
          try {
            if (connection.metadata && connection.metadata.route) {
              // Color if route defined
              this.context.impl.strokeStyle = this.edgeColors[connection.metadata.route];
            } else {
              this.context.impl.strokeStyle = this.edgeColors[0];
            }
            var fromX = Math.round(source.metadata.x*scale+sizeHalf)-0.5;
            var fromY = Math.round(source.metadata.y*scale+sizeHalf)-0.5;
            var toX = Math.round(target.metadata.x*scale+sizeHalf)-0.5;
            var toY = Math.round(target.metadata.y*scale+sizeHalf)-0.5;
            this.context.beginPath();
            this.context.moveTo(fromX, fromY);
            this.context.lineTo(toX, toY);
            this.context.stroke();
          } catch (error) {
            return;
          }
        }.bind(this));    
        // Draw nodes
        this.context.impl.strokeStyle = "black";
        toDraw.forEach(function(node){
          var x = Math.round(node.metadata.x * scale)-0.5;
          var y = Math.round(node.metadata.y * scale)-0.5;
          this.context.fillRect(x,y,size,size);
          this.context.strokeRect(x,y,size,size);
        }.bind(this));
        this.context.impl.strokeStyle = this.strokeStyle;
      },
      graphChanged: function () {
        // TODO changes
        this.redrawGraph();
      },
      resetStyles: function () {
        this.fillStyleChanged();
        this.strokeStyleChanged();
        this.context.impl.lineWidth = this.lineWidth;
      },
      fillStyleChanged: function () {
        this.context.impl.fillStyle = this.fillStyle;
      },
      strokeStyleChanged: function () {
        this.context.impl.strokeStyle = this.strokeStyle;
      },
      widthChanged: function () {
        this.resetStyles();
      },
      heightChanged: function () {
        this.resetStyles();
      },
    });

  })();
  </script>
</polymer-element>
